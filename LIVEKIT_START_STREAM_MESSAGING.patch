--- LiveKit Start Stream Dataclass Messaging Patch ---
=========================================================

This patch adds LiveKit dataclass-based messaging to send start_stream, end_stream,
and other structured events to frontend clients via LiveKit's data channel.

FEATURES ADDED:
- send_stream_event_to_frontend() method for structured messaging
- start_stream event when presentation begins
- end_stream event when presentation completes  
- stop_stream event when manually terminated
- Proper JSON dataclass-like structure with timestamps
- Uses LiveKit publish_data() on "control" topic

FILES MODIFIED:
===============

1. rapido/src/rapido_main.py - Core messaging functionality
2. rapido/src/rapido_api.py - Integration with API endpoints

DETAILED CHANGES:
================

--- a/rapido/src/rapido_main.py
+++ b/rapido/src/rapido_main.py
@@ -108,6 +108,7 @@ import threading
 import queue
 from concurrent.futures import ThreadPoolExecutor
 from typing import Optional
+import time
 import tempfile
 try:
     import torch
@@ -1280,6 +1281,29 @@ class RapidoMainSystem:
         except Exception as e:
             logger.error(f"Error during stream termination: {e}")
     
+    async def send_stream_event_to_frontend(self, event_type: str, **event_data):
+        """Send stream events to frontend via LiveKit data channel"""
+        try:
+            if not hasattr(self, 'lk_room') or not self.lk_room:
+                logger.warning("âš ï¸ Cannot send event - LiveKit room not available")
+                return
+            
+            # Create event in same format as frontend expects
+            event_message = {
+                "id": f"avatar_event_{int(time.time() * 1000)}",
+                "event": event_type,
+                "timestamp": int(time.time() * 1000),
+                **event_data
+            }
+            
+            # Encode same way as frontend  
+            import json
+            data = json.dumps(event_message).encode('utf-8')
+            
+            # Send to all participants via data channel on "control" topic (same as frontend listens)
+            await self.lk_room.local_participant.publish_data(data, topic="control")
+            
+            logger.info(f"ðŸ“¤ Sent event to frontend: {event_type} (id: {event_message['id']})")
+            
+        except Exception as e:
+            logger.error(f"Failed to send stream event: {e}")
+    
     async def _frame_collector_loop(self):
         """Independent frame collector - runs continuously without blocking audio"""
         logger.info("ðŸŽ¬ Frame collector started - collecting frames independently from audio")

@@ -980,6 +1003,14 @@ class RapidoMainSystem:
                 if intake_size >= min_buffer_threshold:
                     buffer_wait_time = time.time() - buffer_wait_start
                     logger.info(f"ðŸŽ¬ âœ… Intake buffer filled! {intake_size} frames ready after {buffer_wait_time:.1f}s - starting steady {target_fps}fps output")
+                    
+                    # Send stream started event to frontend
+                    await self.send_stream_event_to_frontend(
+                        "stream_started", 
+                        message="Avatar presentation stream has started",
+                        target_fps=target_fps,
+                        buffer_size=intake_size
+                    )
                     break
                 
                 # Log buffer filling progress every 2 seconds

@@ -1240,6 +1271,12 @@ class RapidoMainSystem:
         try:
             logger.info("ðŸ›‘ Terminating avatar stream immediately...")
             
+            # Send stream stopped event to frontend first
+            await self.send_stream_event_to_frontend(
+                "stream_stopped",
+                message="Avatar presentation stopped by user command"
+            )
+            
             # Stop all streaming processes
             self.frame_delivery_running = False
             self.tts_streaming_complete = True

--- a/rapido/src/rapido_api.py
+++ b/rapido/src/rapido_api.py
@@ -420,6 +420,16 @@ async def auto_start_presentation(room_name: str, lesson_id: str, video_job_id:
         if success:
             session_info["status"] = "completed"
             logger.info(f"âœ… Presentation completed for lesson: {lesson_id}")
+            
+            # Send stream ended event to frontend if possible
+            if hasattr(rapido, 'send_stream_event_to_frontend'):
+                try:
+                    await rapido.send_stream_event_to_frontend(
+                        "stream_ended",
+                        message="Avatar presentation has completed successfully",
+                        lesson_id=lesson_id,
+                        video_job_id=video_job_id
+                    )
+                except Exception as event_error:
+                    logger.error(f"Failed to send stream_ended event: {event_error}")
         else:
             session_info["status"] = "failed"
             logger.error(f"âŒ Presentation failed for lesson: {lesson_id}")

@@ -490,6 +500,15 @@ async def start_rapido_session(session_id: str, narration_text: str, avatar_nam
         if success:
             session["status"] = "complete"
             logger.info(f"âœ… Presentation completed: {session_id}")
+            
+            # Send stream ended event to frontend
+            if hasattr(rapido, 'send_stream_event_to_frontend'):
+                try:
+                    await rapido.send_stream_event_to_frontend(
+                        "stream_ended",
+                        message="Avatar presentation has completed successfully"
+                    )
+                except Exception as event_error:
+                    logger.error(f"Failed to send stream_ended event: {event_error}")
         else:
             raise Exception("Streaming failed")

DATACLASS-LIKE EVENT STRUCTURE:
===============================

The events sent follow a structured dataclass-like format:

```python
@dataclass
class StreamEvent:
    id: str              # Unique event ID with timestamp
    event: str           # Event type: "stream_started", "stream_ended", "stream_stopped"
    timestamp: int       # Unix timestamp in milliseconds
    message: str         # Human-readable message
    # Additional event-specific fields...
```

Example events:

1. STREAM STARTED:
```json
{
  "id": "avatar_event_1703123456789",
  "event": "stream_started",
  "timestamp": 1703123456789,
  "message": "Avatar presentation stream has started",
  "target_fps": 25,
  "buffer_size": 13
}
```

2. STREAM ENDED:
```json
{
  "id": "avatar_event_1703123556789", 
  "event": "stream_ended",
  "timestamp": 1703123556789,
  "message": "Avatar presentation has completed successfully",
  "lesson_id": "lesson_123",
  "video_job_id": "job_456"
}
```

3. STREAM STOPPED:
```json
{
  "id": "avatar_event_1703123456999",
  "event": "stream_stopped", 
  "timestamp": 1703123456999,
  "message": "Avatar presentation stopped by user command"
}
```

FRONTEND INTEGRATION:
====================

Frontend can listen for these events using LiveKit's data channel:

```javascript
// Listen for data messages on "control" topic
room.on(RoomEvent.DataReceived, (payload, participant, kind, topic) => {
  if (topic === "control") {
    const event = JSON.parse(new TextDecoder().decode(payload));
    
    switch (event.event) {
      case "stream_started":
        console.log("ðŸŽ¬ Avatar presentation started!", event);
        // Show loading spinner, update UI, etc.
        break;
        
      case "stream_ended":
        console.log("âœ… Avatar presentation completed!", event);
        // Hide loading, show completion message, etc.
        break;
        
      case "stream_stopped":
        console.log("ðŸ›‘ Avatar presentation stopped!", event);
        // Handle manual stop, cleanup, etc.
        break;
    }
  }
});
```

USAGE INSTRUCTIONS:
==================

1. Apply this patch to add LiveKit data messaging capability
2. The system will automatically send:
   - "stream_started" when buffer fills and presentation begins
   - "stream_ended" when TTS completes and presentation finishes
   - "stream_stopped" when manually terminated via stop command

3. Frontend should listen on "control" topic for these structured events
4. Events include timestamps, messages, and relevant metadata
5. All events follow consistent dataclass-like structure for easy parsing

BENEFITS:
=========

âœ… Real-time frontend notifications via LiveKit data channel
âœ… Structured, predictable event format (dataclass-like)
âœ… Automatic event sending at key lifecycle points
âœ… Rich metadata for frontend UI updates
âœ… Proper error handling and logging
âœ… Compatible with existing LiveKit infrastructure

This enables rich frontend integration with real-time avatar presentation status!
